import asyncio
import random
from playwright.async_api import async_playwright
import requests
from urllib.parse import urlparse, unquote
import os
from datetime import datetime

# ===== CONFIGURATION =====
BOT_TOKEN = "7619040891:AAF9pfQQme32XvhTfUb97jzky5w4ZEaBzwc"
CHAT_ID = "5172045930"

# Contact variations to try
CONTACT_VARIATIONS = [
 {
        'first_name': 'Lola',
        'last_name': 'Issah',
        'full_name': 'lola issah smith',
        'email': 'lolai1964@hotmail.com',
        'phone': '+1-743-259-3319',
        'phone_formatted': '743-259-3319',
        'company': 'Kevand Co',
        'job_title': 'COO',
        'website': 'kevandco.com',
        'message': 'Hello,\n\nIm Lola, I had a work related accident i need a lawyer to assist with the settlement etc pls leave an email so i explain further\n Thanks.',
        'subject': 'Legal Support',
        'address': '789 Executive Plaza, New York, NY 10031',
        'city': 'New York',
        'state': 'NY',
        'zip': '10031',
        'country': 'USA'
    }
]

# Contact page URL variations
CONTACT_PATHS = [
    '/contact',
    '/contact-us',
    '/contact-form',
    '/get-in-touch',
    '/inquiry',
     '/enquiry',
    '/reach-out',
    '/contact-us/',
    '/contact/'
]

# Bot configuration
MAX_TABS_PER_BROWSER = 25
MAX_PARALLEL_SITES = 10
PAGES_TO_SCAN = 5
REQUEST_DELAY = (0.5, 1.5)
KEYWORDS_FILE = 'keywords.txt'
BLACKLIST_FILE = 'blacklist.txt'
SITE_TIMEOUT = 8
FORM_FILL_TIMEOUT = 5

# Global tracking
visited_domains = set()
blacklist_domains = set()
total_browsers = 0
total_submissions = 0
session_start = datetime.now()

# ===== UTILITY FUNCTIONS =====

def load_blacklist():
    """Load previously processed domains"""
    try:
        if os.path.exists(BLACKLIST_FILE):
            with open(BLACKLIST_FILE, 'r') as f:
                return {line.strip() for line in f if line.strip()}
    except:
        pass
    return set()

def add_to_blacklist(domain):
    """Add domain to blacklist (already submitted)"""
    try:
        blacklist_domains.add(domain)
        with open(BLACKLIST_FILE, 'a') as f:
            f.write(f"{domain}\n")
    except:
        pass

def load_keywords():
    """Load search keywords"""
    try:
        if os.path.exists(KEYWORDS_FILE):
            with open(KEYWORDS_FILE, 'r') as f:
                keywords = [line.strip() for line in f if line.strip()]
                if keywords:
                    return keywords
    except:
        pass
    return ['escrow lawyers']

def send_telegram(image_bytes, caption):
    """Send screenshot to Telegram"""
    try:
        files = {"photo": ("screenshot.png", image_bytes, 'image/png')}
        data = {"chat_id": CHAT_ID, "caption": caption[:1024]}
        requests.post(
            f"https://api.telegram.org/bot{BOT_TOKEN}/sendPhoto",
            files=files, data=data, timeout=5
        )
        return True
    except:
        return False

def send_text_telegram(message):
    """Send text message to Telegram"""
    try:
        data = {
            "chat_id": CHAT_ID,
            "text": message[:4096],
            "parse_mode": "HTML"
        }
        requests.post(
            f"https://api.telegram.org/bot{BOT_TOKEN}/sendMessage",
            json=data, timeout=5
        )
        return True
    except:
        return False

def get_stats():
    """Get session statistics"""
    elapsed = (datetime.now() - session_start).total_seconds()
    return {
        'elapsed': f"{int(elapsed)}s",
        'browsers': total_browsers,
        'submissions': total_submissions,
        'domains_visited': len(visited_domains),
        'rate': f"{(total_submissions / max(len(visited_domains), 1) * 100):.1f}%"
    }

# ===== MAIN BOT CLASS =====

class FormBot:
    def __init__(self):
        self.playwright = None
        self.browser = None
        self.context = None
        self.search_page = None
        self.open_tabs = 0
        self.keywords = []
        self.pending_tabs = []  # NEW: Track pending review tabs

    async def initialize(self):
        """Start browser and load keywords"""
        global total_browsers
        self.keywords = load_keywords()
        self.playwright = await async_playwright().start()
        await self.create_browser()

    async def create_browser(self):
        """Create new browser instance"""
        global total_browsers
        total_browsers += 1
        
        print(f"\n{'='*60}")
        print(f"ğŸªŸ BROWSER #{total_browsers} STARTING")
        print(f"{'='*60}")
        
        self.browser = await self.playwright.chromium.launch(
            headless=False,
            args=['--start-maximized', '--disable-blink-features=AutomationControlled']
        )
        
        self.context = await self.browser.new_context(
            viewport={'width': 1365, 'height': 901}
        )
        
        self.search_page = await self.context.new_page()
        self.open_tabs = 1
        
        send_text_telegram(f"ğŸªŸ BROWSER #{total_browsers} READY\nğŸ“ Max: {MAX_TABS_PER_BROWSER} tabs\nğŸ” Scanning: {', '.join(self.keywords[:3])}")

    async def create_tab(self):
        """Create new tab"""
        self.open_tabs += 1
        if self.open_tabs > MAX_TABS_PER_BROWSER:
            print(f"ğŸªŸ Max tabs reached - creating new browser")
            await self.browser.close()
            await self.create_browser()
        return await self.context.new_page()

    async def close_popups(self, page):
        """Quick popup closing"""
        try:
            selectors = [
                "button.close", ".close", "[aria-label*='close' i]",
                "button:has-text('Close')", "button:has-text('X')"
            ]
            for selector in selectors[:3]:
                try:
                    btns = await page.query_selector_all(selector)
                    for btn in btns[:2]:
                        if await btn.is_visible():
                            await btn.click(timeout=1000)
                            await asyncio.sleep(0.1)
                except:
                    pass
        except Exception as e:
            pass

    async def find_contact_page(self, page, base_url):
        """Try to find contact page"""
        domain = urlparse(base_url).netloc
        
        # Try direct /contact paths
        for path in CONTACT_PATHS[:3]:
            try:
                url = f"{base_url.rstrip('/')}{path}"
                await asyncio.wait_for(
                    page.goto(url, wait_until='domcontentloaded'),
                    timeout=SITE_TIMEOUT
                )
                await asyncio.sleep(0.3)
                
                # Check if has form
                forms = await page.query_selector_all('input, textarea, form')
                if len(forms) >= 2:
                    return url
            except:
                pass
        
        # Try homepage and search for contact link
        try:
            await asyncio.wait_for(
                page.goto(base_url, wait_until='domcontentloaded'),
                timeout=SITE_TIMEOUT
            )
            await asyncio.sleep(0.3)
            await self.close_popups(page)
            
            links = await page.query_selector_all('a')
            for link in links:
                try:
                    href = await link.get_attribute('href')
                    text = (await link.text_content() or '').lower()
                    
                    if not href:
                        continue
                    
                    if 'contact' in href.lower() or 'contact' in text:
                        full_url = href if href.startswith('http') else f"{base_url.rstrip('/')}{href}"
                        
                        try:
                            await asyncio.wait_for(
                                page.goto(full_url, wait_until='domcontentloaded'),
                                timeout=SITE_TIMEOUT
                            )
                            await asyncio.sleep(0.3)
                            forms = await page.query_selector_all('input, textarea, form')
                            if len(forms) >= 2:
                                return full_url
                        except:
                            pass
                except:
                    pass
        except:
            pass
        
        return None

    async def fill_form_only(self, page, contact_url, contact_info):
        """Fill form but DON'T submit - leave for manual review"""
        try:
            await asyncio.wait_for(
                page.goto(contact_url, wait_until='domcontentloaded'),
                timeout=SITE_TIMEOUT
            )
            await asyncio.sleep(0.5)
            await self.close_popups(page)
            
            # Get all fillable inputs
            inputs = await page.query_selector_all('input[type="text"], input[type="email"], input[type="tel"], textarea')
            
            filled_count = 0
            
            # Simple strategy: just fill everything we can match
            for inp in inputs:
                try:
                    # Get field identifier
                    name = (await inp.get_attribute('name') or '').lower()
                    field_id = (await inp.get_attribute('id') or '').lower()
                    placeholder = (await inp.get_attribute('placeholder') or '').lower()
                    
                    identifier = f"{name} {field_id} {placeholder}".lower()
                    
                    # Try to match and fill
                    value = None
                    
                    if 'first' in identifier:
                        value = contact_info['first_name']
                    elif 'last' in identifier:
                        value = contact_info['last_name']
                    elif 'name' in identifier:
                        value = contact_info['full_name']
                    elif 'email' in identifier:
                        value = contact_info['email']
                    elif 'phone' in identifier or 'tel' in identifier or 'mobile' in identifier:
                        value = contact_info['phone_formatted']
                    elif 'company' in identifier or 'business' in identifier or 'firm' in identifier:
                        value = contact_info['company']
                    elif 'title' in identifier or 'position' in identifier:
                        value = contact_info['job_title']
                    elif 'message' in identifier or 'comment' in identifier or 'inquiry' in identifier:
                        value = contact_info['message']
                    elif 'subject' in identifier:
                        value = contact_info['subject']
                    elif 'address' in identifier or 'street' in identifier:
                        value = contact_info['address']
                    elif 'city' in identifier:
                        value = contact_info['city']
                    elif 'state' in identifier:
                        value = contact_info['state']
                    elif 'zip' in identifier or 'postal' in identifier:
                        value = contact_info['zip']
                    elif 'country' in identifier:
                        value = contact_info['country']
                    
                    if value:
                        await inp.fill(value)
                        filled_count += 1
                        await asyncio.sleep(0.05)
                except:
                    pass
            
            if filled_count == 0:
                return 'no_fill', 0
            
            # Check and click checkboxes (especially terms/agreements)
            checkboxes = await page.query_selector_all('input[type="checkbox"]')
            for checkbox in checkboxes:
                try:
                    if await checkbox.is_visible():
                        label_text = ""
                        try:
                            checkbox_id = await checkbox.get_attribute('id')
                            if checkbox_id:
                                label = await page.query_selector(f'label[for="{checkbox_id}"]')
                                if label:
                                    label_text = (await label.text_content()).lower()
                        except:
                            pass
                        
                        # Check boxes related to terms, agreement, etc
                        if any(x in label_text for x in ['terms', 'agree', 'accept', 'consent', 'privacy']):
                            if not await checkbox.is_checked():
                                await checkbox.check()
                                await asyncio.sleep(0.1)
                except:
                    pass
            
            # DON'T submit - leave form filled for manual review
            # Just scroll to show the form and take screenshot
            
            # Small pause for form to settle
            await asyncio.sleep(0.5)
            
            # Try to scroll form into view
            try:
                await page.evaluate('''() => {
                    const form = document.querySelector('form');
                    if (form) form.scrollIntoView({behavior: 'smooth', block: 'center'});
                }''')
            except:
                pass
            
            # Take screenshot of FILLED form (not result page)
            screenshot = await page.screenshot(full_page=False)
            
            # Return "filled" status instead of "submitted"
            return 'filled', filled_count, screenshot
            
        except Exception as e:
            return 'error', 0, str(e)

    async def process_site(self, website_url, keyword):
        """Process single website"""
        domain = urlparse(website_url).netloc
        
        if domain in blacklist_domains or domain in visited_domains:
            return
        
        visited_domains.add(domain)
        print(f"ğŸŒ {domain}")
        
        page = await self.create_tab()
        
        try:
            # Find contact page
            contact_url = await self.find_contact_page(page, website_url)
            if not contact_url:
                await page.close()
                add_to_blacklist(domain)
                return
            
            # Try each contact variation
            for variation_idx, contact_info in enumerate(CONTACT_VARIATIONS):
                try:
                    result = await self.fill_form_only(page, contact_url, contact_info)
                    
                    if result[0] == 'filled':
                        # Form filled but NOT submitted - send notification
                        filled = result[1]
                        screenshot = result[2]
                        
                        # Get browser and tab info
                        browser_num = total_browsers
                        tab_num = self.open_tabs
                        
                        caption = (
                            f"ğŸŸ¡ READY FOR REVIEW\n"
                            f"ğŸŒ {domain}\n"
                            f"ğŸ”— {contact_url}\n"
                            f"ğŸ“ Filled: {filled} fields\n"
                            f"ğŸ”‘ Keyword: {keyword}\n"
                            f"ğŸªŸ Browser #{browser_num} - Tab #{tab_num}"
                        )
                        
                        send_telegram(screenshot, caption)
                        print(f"  ğŸŸ¡ READY (Browser{browser_num}-Tab{tab_num})")
                        
                        # Store tab info for tracking
                        self.pending_tabs.append({
                            'browser': total_browsers,
                            'tab': self.open_tabs,
                            'domain': domain,
                            'page': page,
                            'contact_url': contact_url,
                            'filled_count': filled
                        })
                        
                        # DON'T add to blacklist yet (wait for manual submission)
                        # DON'T close the page - leave it open for review
                        return  # Keep tab open!
                    
                    elif result[0] in ['no_submit', 'no_fill']:
                        # Try next variation
                        if variation_idx < len(CONTACT_VARIATIONS) - 1:
                            await asyncio.sleep(0.5)
                            continue
                        else:
                            # Last variation failed
                            await page.close()
                            add_to_blacklist(domain)
                            return
                    
                    elif result[0] == 'error':
                        if variation_idx < len(CONTACT_VARIATIONS) - 1:
                            await asyncio.sleep(0.5)
                            continue
                        else:
                            await page.close()
                            add_to_blacklist(domain)
                            return
                    
                except asyncio.TimeoutError:
                    if variation_idx >= len(CONTACT_VARIATIONS) - 1:
                        await page.close()
                        add_to_blacklist(domain)
                    continue
                
            # If we get here, all variations failed
            await page.close()
            add_to_blacklist(domain)
            
        except Exception as e:
            print(f"  âŒ Error: {str(e)[:40]}")
            try:
                await page.close()
            except:
                pass
            add_to_blacklist(domain)

    async def extract_google_results(self):
        """Extract URLs from current Google search page"""
        await asyncio.sleep(1)
        
        results = []
        links = await self.search_page.query_selector_all('a')
        
        for link in links:
            try:
                href = await link.get_attribute('href')
                if not href:
                    continue
                
                if '/url?q=' in href:
                    url = href.split('/url?q=')[1].split('&')[0]
                    url = unquote(url)
                elif href.startswith('http'):
                    url = href
                else:
                    continue
                
                # Filter out social/tracking
                if any(x in url.lower() for x in ['google.com', 'youtube', 'facebook', 'linkedin', 'twitter', 'javascript:']):
                    continue
                
                results.append(url)
            except:
                pass
        
        return list(set(results))

    async def process_batch(self, websites, keyword):
        """Process sites in parallel"""
        tasks = [
            asyncio.create_task(self.process_site(website, keyword))
            for website in websites
        ]
        await asyncio.gather(*tasks, return_exceptions=True)

    async def scan_keyword(self, keyword):
        """Scan Google for keyword and process results"""
        global total_browsers  # Moved this to the top of the function
        
        print(f"\n{'='*60}")
        print(f"ğŸ” KEYWORD: {keyword}")
        print(f"{'='*60}")
        
        search_url = f"https://www.google.com/search?q={keyword.replace(' ', '+')}"
        
        try:
            await asyncio.wait_for(
                self.search_page.goto(search_url, wait_until='domcontentloaded'),
                timeout=10
            )
            await asyncio.sleep(2)
        except:
            print("âš ï¸ Google timeout")
            return
        
        # Handle Google CAPTCHA
        if "google.com/sorry" in self.search_page.url:
            print("ğŸš¨ GOOGLE CAPTCHA - Please solve manually")
            input(">>> Press ENTER after solving <<<")
            try:
                await self.search_page.reload()
                await asyncio.sleep(2)
            except:
                pass
        
        # Process pages
        for page_num in range(1, PAGES_TO_SCAN + 1):
            print(f"\nğŸ“„ Page {page_num}")
            
            results = await self.extract_google_results()
            print(f"  ğŸ“Œ Found {len(results)} URLs")
            
            if results:
                # Process in batches
                for i in range(0, len(results), MAX_PARALLEL_SITES):
                    batch = results[i:i + MAX_PARALLEL_SITES]
                    await self.process_batch(batch, keyword)
                    
                    stats = get_stats()
                    print(f"  â±ï¸ {stats['elapsed']} | âœ… {stats['submissions']} | ğŸ“Š {stats['rate']}")
                    await asyncio.sleep(0.5)
            
            # Next page
            if page_num < PAGES_TO_SCAN:
                try:
                    next_url = f"{search_url}&start={page_num * 10}"
                    await asyncio.wait_for(
                        self.search_page.goto(next_url, wait_until='domcontentloaded'),
                        timeout=10
                    )
                    await asyncio.sleep(1)
                except:
                    break
        
        # Check if we should pause after reaching 5 browsers
        if total_browsers >= 5:  # After 5 browsers (125 tabs)
            print(f"\n{'='*60}")
            print(f"â¸ï¸ PAUSED - {total_browsers} browsers ready for review")
            print(f"ğŸ“‹ Approximately {total_browsers * 25} tabs to review")
            print(f"{'='*60}")
            
            # Send summary to Telegram
            msg = (
                f"â¸ï¸ BOT PAUSED\n"
                f"ğŸªŸ {total_browsers} browsers ready for review\n"
                f"ğŸ“‹ ~{total_browsers * 25} tabs filled\n"
                f"â° Time for manual review!\n"
                f"ğŸ” Keyword: {keyword}"
            )
            send_text_telegram(msg)
            
            # Wait for user to finish review
            input("\n>>> Press ENTER when ready to continue (or Ctrl+C to stop)...")
            
            # Reset browser count for next batch
            total_browsers = 0

    async def run(self):
        """Main bot loop"""
        print("\n" + "="*60)
        print("ğŸš€ FORM ASSISTANT - MANUAL REVIEW MODE")
        print("="*60)
        print("âš¡ FEATURES:")
        print("  â€¢ Fills forms but DOESN'T submit")
        print("  â€¢ Keeps tabs open for manual review")
        print("  â€¢ Notifies via Telegram with tab numbers")
        print("  â€¢ Pauses after 5 browsers (125 tabs)")
        print("  â€¢ You review and submit manually")
        print("="*60)
        
        await self.initialize()
        
        cycle = 0
        while True:
            cycle += 1
            print(f"\n{'='*60}")
            print(f"ğŸ”„ CYCLE {cycle}")
            print(f"{'='*60}")
            
            for keyword in self.keywords:
                await self.scan_keyword(keyword)
            
            stats = get_stats()
            msg = (
                f"ğŸŠ <b>CYCLE {cycle} COMPLETE</b>\n"
                f"â±ï¸ {stats['elapsed']}\n"
                f"ğŸ“ {len(self.pending_tabs)} tabs ready for review\n"
                f"ğŸŒ {stats['domains_visited']} domains visited\n"
                f"ğŸªŸ {stats['browsers']} browsers created"
            )
            send_text_telegram(msg)
            print(f"\n{msg}\n")
            
            print("â³ Waiting 30s before next cycle...")
            await asyncio.sleep(30)

async def main():
    global blacklist_domains
    blacklist_domains = load_blacklist()
    
    bot = FormBot()
    try:
        await bot.run()
    except KeyboardInterrupt:
        print("\n\nâ¸ï¸ BOT STOPPED")
        print("âœ… Browsers remain open for manual review")
        print(f"ğŸ“‹ You have {len(bot.pending_tabs)} tabs to review")
        print("ğŸ“ Restart script to continue\n")

if __name__ == "__main__":
    try:
        asyncio.run(main())
    except KeyboardInterrupt:
        print("\nâ¸ï¸ STOPPED\n")
