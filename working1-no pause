import time
import random
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.common.exceptions import TimeoutException, NoSuchElementException
import requests
from urllib.parse import urlparse, unquote
import os
from datetime import datetime
import threading

# ===== CONFIGURATION =====
BOT_TOKEN = "7619040891:AAF9pfQQme32XvhTfUb97jzky5w4ZEaBzwc"
CHAT_ID = "5172045930"

# Contact variations to try
CONTACT_VARIATIONS = [
 {
        'first_name': 'Lola',
        'last_name': 'Issah',
        'full_name': 'lola issah smith',
        'email': 'lolai1964@hotmail.com',
        'phone': '+1-743-259-3319',
        'phone_formatted': '743-259-3319',
        'company': 'Kevand Co',
        'job_title': 'COO',
        'website': 'kevandco.com',
        'message': 'Hello,\n\nIm Lola, I had a work related accident i need a lawyer to assist with the settlement etc pls leave an email so i explain further\n Thanks.',
        'subject': 'Legal Support',
        'address': '789 Executive Plaza, New York, NY 10031',
        'city': 'New York',
        'state': 'NY',
        'zip': '10031',
        'country': 'USA'
    }
]

# Contact page URL variations
CONTACT_PATHS = [
    '/contact',
    '/contact-us',
    '/contact-form',
    '/get-in-touch',
    '/inquiry',
    '/enquiry',
    '/reach-out',
    '/contact-us/',
    '/contact/'
]

# Bot configuration
MAX_TABS_PER_BROWSER = 25
PAGES_TO_SCAN = 5
KEYWORDS_FILE = 'keywords.txt'
BLACKLIST_FILE = 'blacklist.txt'
SITE_TIMEOUT = 8  # seconds
FORM_FILL_TIMEOUT = 5

# Global tracking
visited_domains = set()
blacklist_domains = set()
total_browsers = 0
total_submissions = 0
session_start = datetime.now()
lock = threading.Lock()

# ===== UTILITY FUNCTIONS =====

def load_blacklist():
    """Load previously processed domains"""
    try:
        if os.path.exists(BLACKLIST_FILE):
            with open(BLACKLIST_FILE, 'r') as f:
                return {line.strip() for line in f if line.strip()}
    except:
        pass
    return set()

def add_to_blacklist(domain):
    """Add domain to blacklist"""
    try:
        blacklist_domains.add(domain)
        with open(BLACKLIST_FILE, 'a') as f:
            f.write(f"{domain}\n")
    except:
        pass

def load_keywords():
    """Load search keywords"""
    try:
        if os.path.exists(KEYWORDS_FILE):
            with open(KEYWORDS_FILE, 'r') as f:
                keywords = [line.strip() for line in f if line.strip()]
                if keywords:
                    return keywords
    except:
        pass
    return ['escrow lawyers']

def send_telegram(image_bytes, caption):
    """Send screenshot to Telegram"""
    try:
        files = {"photo": ("screenshot.png", image_bytes, 'image/png')}
        data = {"chat_id": CHAT_ID, "caption": caption[:1024]}
        requests.post(
            f"https://api.telegram.org/bot{BOT_TOKEN}/sendPhoto",
            files=files, data=data, timeout=5
        )
        return True
    except:
        return False

def send_text_telegram(message):
    """Send text message to Telegram"""
    try:
        data = {
            "chat_id": CHAT_ID,
            "text": message[:4096],
            "parse_mode": "HTML"
        }
        requests.post(
            f"https://api.telegram.org/bot{BOT_TOKEN}/sendMessage",
            json=data, timeout=5
        )
        return True
    except:
        return False

def get_stats():
    """Get session statistics"""
    elapsed = (datetime.now() - session_start).total_seconds()
    return {
        'elapsed': f"{int(elapsed)}s",
        'browsers': total_browsers,
        'submissions': total_submissions,
        'domains_visited': len(visited_domains),
        'rate': f"{(total_submissions / max(len(visited_domains), 1) * 100):.1f}%"
    }

# ===== BROWSER MANAGER CLASS =====

class BrowserManager:
    """Manages a single browser instance with multiple tabs"""
    
    def __init__(self, browser_id):
        self.browser_id = browser_id
        self.driver = None
        self.tab_count = 0
        self.pending_tabs = []
        self.window_handles = []
        
    def initialize(self):
        """Start this browser instance"""
        print(f"\n{'='*60}")
        print(f"ü™ü BROWSER #{self.browser_id} STARTING")
        print(f"{'='*60}")
        
        options = webdriver.ChromeOptions()
        options.add_argument('--start-maximized')
        options.add_argument('--disable-blink-features=AutomationControlled')
        options.add_experimental_option("excludeSwitches", ["enable-automation"])
        options.add_experimental_option('useAutomationExtension', False)
        
        self.driver = webdriver.Chrome(options=options)
        self.driver.set_window_size(1365, 901)
        
        # Initial tab (search tab)
        self.window_handles.append(self.driver.current_window_handle)
        self.tab_count = 1
        
        send_text_telegram(f"ü™ü BROWSER #{self.browser_id} READY\nüìù Max: {MAX_TABS_PER_BROWSER} tabs")
        
    def create_tab(self):
        """Create new tab in this browser"""
        self.tab_count += 1
        self.driver.execute_script("window.open('');")
        self.window_handles = self.driver.window_handles
        self.driver.switch_to.window(self.window_handles[-1])
        return self.driver
    
    def switch_to_search_tab(self):
        """Switch back to the search tab (first tab)"""
        self.driver.switch_to.window(self.window_handles[0])
    
    def can_accept_tabs(self):
        """Check if this browser can accept more tabs"""
        return self.tab_count < MAX_TABS_PER_BROWSER
    
    def is_full(self):
        """Check if browser is at max capacity"""
        return self.tab_count >= MAX_TABS_PER_BROWSER

# ===== MAIN BOT CLASS =====

class FormBot:
    def __init__(self):
        self.browsers = []
        self.current_browser = None
        self.keywords = []
        self.all_pending_tabs = []

    def initialize(self):
        """Start browser and load keywords"""
        global total_browsers
        self.keywords = load_keywords()
        self.create_new_browser()

    def create_new_browser(self):
        """Create a brand new browser instance"""
        global total_browsers
        total_browsers += 1
        
        browser_manager = BrowserManager(total_browsers)
        browser_manager.initialize()
        
        self.browsers.append(browser_manager)
        self.current_browser = browser_manager
        
        return browser_manager

    def get_available_browser(self):
        """Get a browser that can accept more tabs, or create new one"""
        with lock:
            # Check if current browser can accept tabs
            if self.current_browser and self.current_browser.can_accept_tabs():
                return self.current_browser
            
            # Current browser is full, try to find another available browser
            for browser in self.browsers:
                if browser.can_accept_tabs():
                    self.current_browser = browser
                    print(f"üîÑ Switching to Browser #{browser.browser_id} ({browser.tab_count}/{MAX_TABS_PER_BROWSER} tabs)")
                    return browser
            
            # All browsers are full, create a new one
            print(f"\nü™ü All browsers at capacity - creating new browser")
            return self.create_new_browser()

    def create_tab(self):
        """Create new tab (handles browser switching automatically)"""
        browser = self.get_available_browser()
        return browser.create_tab()

    def close_popups(self, driver):
        """Quick popup closing"""
        try:
            selectors = [
                "button.close", ".close", "[aria-label*='close' i]",
                "button:contains('Close')", "button:contains('X')"
            ]
            for selector in selectors[:3]:
                try:
                    elements = driver.find_elements(By.CSS_SELECTOR, selector)
                    for elem in elements[:2]:
                        if elem.is_displayed():
                            elem.click()
                            time.sleep(0.1)
                except:
                    pass
        except:
            pass

    def find_contact_page(self, driver, base_url):
        """Try to find contact page"""
        domain = urlparse(base_url).netloc
        
        # Try direct /contact paths
        for path in CONTACT_PATHS[:3]:
            try:
                url = f"{base_url.rstrip('/')}{path}"
                driver.set_page_load_timeout(SITE_TIMEOUT)
                driver.get(url)
                time.sleep(0.3)
                
                # Check if has form
                inputs = driver.find_elements(By.CSS_SELECTOR, 'input, textarea, form')
                if len(inputs) >= 2:
                    return url
            except:
                pass
        
        # Try homepage and search for contact link
        try:
            driver.set_page_load_timeout(SITE_TIMEOUT)
            driver.get(base_url)
            time.sleep(0.3)
            self.close_popups(driver)
            
            links = driver.find_elements(By.TAG_NAME, 'a')
            for link in links:
                try:
                    href = link.get_attribute('href')
                    text = link.text.lower()
                    
                    if not href:
                        continue
                    
                    if 'contact' in href.lower() or 'contact' in text:
                        full_url = href if href.startswith('http') else f"{base_url.rstrip('/')}{href}"
                        
                        try:
                            driver.get(full_url)
                            time.sleep(0.3)
                            inputs = driver.find_elements(By.CSS_SELECTOR, 'input, textarea, form')
                            if len(inputs) >= 2:
                                return full_url
                        except:
                            pass
                except:
                    pass
        except:
            pass
        
        return None

    def fill_form_only(self, driver, contact_url, contact_info):
        """Fill form but DON'T submit - leave for manual review"""
        try:
            driver.set_page_load_timeout(SITE_TIMEOUT)
            driver.get(contact_url)
            time.sleep(0.5)
            self.close_popups(driver)
            
            # Get all fillable inputs
            inputs = driver.find_elements(By.CSS_SELECTOR, 'input[type="text"], input[type="email"], input[type="tel"], textarea')
            
            filled_count = 0
            
            # Fill fields
            for inp in inputs:
                try:
                    name = (inp.get_attribute('name') or '').lower()
                    field_id = (inp.get_attribute('id') or '').lower()
                    placeholder = (inp.get_attribute('placeholder') or '').lower()
                    
                    identifier = f"{name} {field_id} {placeholder}".lower()
                    
                    value = None
                    
                    if 'first' in identifier:
                        value = contact_info['first_name']
                    elif 'last' in identifier:
                        value = contact_info['last_name']
                    elif 'name' in identifier:
                        value = contact_info['full_name']
                    elif 'email' in identifier:
                        value = contact_info['email']
                    elif 'phone' in identifier or 'tel' in identifier or 'mobile' in identifier:
                        value = contact_info['phone_formatted']
                    elif 'company' in identifier or 'business' in identifier or 'firm' in identifier:
                        value = contact_info['company']
                    elif 'title' in identifier or 'position' in identifier:
                        value = contact_info['job_title']
                    elif 'message' in identifier or 'comment' in identifier or 'inquiry' in identifier:
                        value = contact_info['message']
                    elif 'subject' in identifier:
                        value = contact_info['subject']
                    elif 'address' in identifier or 'street' in identifier:
                        value = contact_info['address']
                    elif 'city' in identifier:
                        value = contact_info['city']
                    elif 'state' in identifier:
                        value = contact_info['state']
                    elif 'zip' in identifier or 'postal' in identifier:
                        value = contact_info['zip']
                    elif 'country' in identifier:
                        value = contact_info['country']
                    
                    if value:
                        inp.clear()
                        inp.send_keys(value)
                        filled_count += 1
                        time.sleep(0.05)
                except:
                    pass
            
            if filled_count == 0:
                return 'no_fill', 0
            
            # Check checkboxes
            checkboxes = driver.find_elements(By.CSS_SELECTOR, 'input[type="checkbox"]')
            for checkbox in checkboxes:
                try:
                    if checkbox.is_displayed():
                        label_text = ""
                        try:
                            checkbox_id = checkbox.get_attribute('id')
                            if checkbox_id:
                                labels = driver.find_elements(By.CSS_SELECTOR, f'label[for="{checkbox_id}"]')
                                if labels:
                                    label_text = labels[0].text.lower()
                        except:
                            pass
                        
                        if any(x in label_text for x in ['terms', 'agree', 'accept', 'consent', 'privacy']):
                            if not checkbox.is_selected():
                                checkbox.click()
                                time.sleep(0.1)
                except:
                    pass
            
            time.sleep(0.5)
            
            # Scroll form into view
            try:
                driver.execute_script('''
                    const form = document.querySelector('form');
                    if (form) form.scrollIntoView({behavior: 'smooth', block: 'center'});
                ''')
            except:
                pass
            
            # Take screenshot
            screenshot = driver.get_screenshot_as_png()
            
            return 'filled', filled_count, screenshot
            
        except Exception as e:
            return 'error', 0, str(e)

    def process_site(self, website_url, keyword):
        """Process single website"""
        domain = urlparse(website_url).netloc
        
        if domain in blacklist_domains or domain in visited_domains:
            return
        
        visited_domains.add(domain)
        print(f"üåê {domain}")
        
        driver = self.create_tab()
        
        try:
            # Find contact page
            contact_url = self.find_contact_page(driver, website_url)
            if not contact_url:
                add_to_blacklist(domain)
                return
            
            # Try each contact variation
            for variation_idx, contact_info in enumerate(CONTACT_VARIATIONS):
                try:
                    result = self.fill_form_only(driver, contact_url, contact_info)
                    
                    if result[0] == 'filled':
                        filled = result[1]
                        screenshot = result[2]
                        
                        browser_num = self.current_browser.browser_id
                        tab_num = self.current_browser.tab_count
                        
                        caption = (
                            f"üü° READY FOR REVIEW\n"
                            f"üåê {domain}\n"
                            f"üîó {contact_url}\n"
                            f"üìù Filled: {filled} fields\n"
                            f"üîë Keyword: {keyword}\n"
                            f"ü™ü Browser #{browser_num} - Tab #{tab_num}"
                        )
                        
                        send_telegram(screenshot, caption)
                        print(f"  üü° READY (Browser{browser_num}-Tab{tab_num})")
                        
                        tab_info = {
                            'browser': browser_num,
                            'tab': tab_num,
                            'domain': domain,
                            'contact_url': contact_url,
                            'filled_count': filled
                        }
                        
                        self.current_browser.pending_tabs.append(tab_info)
                        self.all_pending_tabs.append(tab_info)
                        
                        return  # Keep tab open!
                    
                    elif result[0] in ['no_submit', 'no_fill']:
                        if variation_idx < len(CONTACT_VARIATIONS) - 1:
                            time.sleep(0.5)
                            continue
                        else:
                            add_to_blacklist(domain)
                            return
                    
                    elif result[0] == 'error':
                        if variation_idx < len(CONTACT_VARIATIONS) - 1:
                            time.sleep(0.5)
                            continue
                        else:
                            add_to_blacklist(domain)
                            return
                    
                except Exception as e:
                    if variation_idx >= len(CONTACT_VARIATIONS) - 1:
                        add_to_blacklist(domain)
                    continue
                
            add_to_blacklist(domain)
            
        except Exception as e:
            print(f"  ‚ùå Error: {str(e)[:40]}")
            add_to_blacklist(domain)

    def extract_google_results(self):
        """Extract URLs from current Google search page"""
        time.sleep(1)
        
        results = []
        driver = self.current_browser.driver
        
        links = driver.find_elements(By.TAG_NAME, 'a')
        
        for link in links:
            try:
                href = link.get_attribute('href')
                if not href:
                    continue
                
                if '/url?q=' in href:
                    url = href.split('/url?q=')[1].split('&')[0]
                    url = unquote(url)
                elif href.startswith('http'):
                    url = href
                else:
                    continue
                
                if any(x in url.lower() for x in ['google.com', 'youtube', 'facebook', 'linkedin', 'twitter', 'javascript:']):
                    continue
                
                results.append(url)
            except:
                pass
        
        return list(set(results))

    def scan_keyword(self, keyword):
        """Scan Google for keyword and process results"""
        global total_browsers
        
        print(f"\n{'='*60}")
        print(f"üîç KEYWORD: {keyword}")
        print(f"{'='*60}")
        
        search_url = f"https://www.google.com/search?q={keyword.replace(' ', '+')}"
        
        # Switch to search tab
        self.current_browser.switch_to_search_tab()
        
        try:
            self.current_browser.driver.set_page_load_timeout(10)
            self.current_browser.driver.get(search_url)
            time.sleep(2)
        except:
            print("‚ö†Ô∏è Google timeout")
            return
        
        # Handle Google CAPTCHA
        if "google.com/sorry" in self.current_browser.driver.current_url:
            print("üö® GOOGLE CAPTCHA - Please solve manually")
            input(">>> Press ENTER after solving <<<")
            try:
                self.current_browser.driver.refresh()
                time.sleep(2)
            except:
                pass
        
        # Process pages
        for page_num in range(1, PAGES_TO_SCAN + 1):
            print(f"\nüìÑ Page {page_num}")
            
            results = self.extract_google_results()
            print(f"  üìå Found {len(results)} URLs")
            
            if results:
                for url in results:
                    self.process_site(url, keyword)
                    
                    # Switch back to search tab after processing
                    self.current_browser.switch_to_search_tab()
                    
                    stats = get_stats()
                    print(f"  ‚è±Ô∏è {stats['elapsed']} | üìã {len(self.all_pending_tabs)} filled | üìä {stats['rate']}")
                    time.sleep(0.5)
            
            # Next page
            if page_num < PAGES_TO_SCAN:
                try:
                    next_url = f"{search_url}&start={page_num * 10}"
                    self.current_browser.switch_to_search_tab()
                    self.current_browser.driver.get(next_url)
                    time.sleep(1)
                except:
                    break
        
        # Check if we should pause after reaching 5 browsers
        if total_browsers >= 5:
            print(f"\n{'='*60}")
            print(f"‚è∏Ô∏è PAUSED - {total_browsers} browsers ready for review")
            print(f"üìã {len(self.all_pending_tabs)} tabs filled and waiting")
            print(f"{'='*60}")
            
            for browser in self.browsers:
                print(f"  ü™ü Browser #{browser.browser_id}: {len(browser.pending_tabs)} tabs")
            
            msg = (
                f"‚è∏Ô∏è BOT PAUSED\n"
                f"ü™ü {total_browsers} browsers ready for review\n"
                f"üìã {len(self.all_pending_tabs)} tabs filled\n"
                f"‚è∞ Time for manual review!\n"
                f"üîç Keyword: {keyword}"
            )
            send_text_telegram(msg)
            
            input("\n>>> Press ENTER when ready to continue (or Ctrl+C to stop)...")

    def run(self):
        """Main bot loop"""
        print("\n" + "="*60)
        print("üöÄ FORM ASSISTANT - MANUAL REVIEW MODE")
        print("="*60)
        print("‚ö° FEATURES:")
        print("  ‚Ä¢ Fills forms but DOESN'T submit")
        print("  ‚Ä¢ Keeps ALL browsers and tabs open")
        print("  ‚Ä¢ Creates new browsers when needed (25 tabs each)")
        print("  ‚Ä¢ Notifies via Telegram with tab numbers")
        print("  ‚Ä¢ Pauses after 5 browsers (125 tabs)")
        print("  ‚Ä¢ You review and submit manually")
        print("="*60)
        
        self.initialize()
        
        cycle = 0
        while True:
            cycle += 1
            print(f"\n{'='*60}")
            print(f"üîÑ CYCLE {cycle}")
            print(f"{'='*60}")
            
            for keyword in self.keywords:
                self.scan_keyword(keyword)
            
            stats = get_stats()
            msg = (
                f"üéä <b>CYCLE {cycle} COMPLETE</b>\n"
                f"‚è±Ô∏è {stats['elapsed']}\n"
                f"üìù {len(self.all_pending_tabs)} tabs ready for review\n"
                f"üåê {stats['domains_visited']} domains visited\n"
                f"ü™ü {stats['browsers']} browsers created"
            )
            send_text_telegram(msg)
            print(f"\n{msg}\n")
            
            print("‚è≥ Waiting 30s before next cycle...")
            time.sleep(30)

def main():
    global blacklist_domains
    blacklist_domains = load_blacklist()
    
    bot = FormBot()
    try:
        bot.run()
    except KeyboardInterrupt:
        print("\n\n‚è∏Ô∏è BOT STOPPED")
        print("‚úÖ All browsers remain open for manual review")
        print(f"üìã You have {len(bot.all_pending_tabs)} tabs to review across {len(bot.browsers)} browsers")
        for browser in bot.browsers:
            print(f"  ü™ü Browser #{browser.browser_id}: {len(browser.pending_tabs)} tabs")
        print("üìù Restart script to continue\n")

if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        print("\n‚è∏Ô∏è STOPPED\n")
