import asyncio
import random
from playwright.async_api import async_playwright
import requests
from urllib.parse import urlparse, unquote
import os
from datetime import datetime
import json

# === CONFIGURATION ===
BOT_TOKEN = "7619040891:AAF9pfQQme32XvhTfUb97jzky5w4ZEaBzwc"
CHAT_ID = "5172045930"

# REAL CONTACT DETAILS - Kevin Fang, CEO of Kevand Co
CONTACT_INFO = {
    'first_name': 'Kevin',
    'last_name': 'Fang',
    'full_name': 'Kevin Fang',
    'email': 'kevandcoceo@hotmail.com',
    'phone': '+1-555-0198',
    'company': 'Kevand Co',
    'job_title': 'CEO',
    'website': 'www.kevandco.com',
    'message': (
        'Good day,\n\n'
        'My name is Kevin Fang, and I serve as CEO of Kevand Co. '
        'We are currently exploring legal partnerships and would greatly appreciate '
        'the opportunity to discuss how your firm\'s expertise could support our business objectives. '
        'I would be grateful for a consultation at your earliest convenience to explore potential collaboration.\n\n'
        'Looking forward to connecting with you.\n\n'
        'Best regards,\n'
        'Kevin Fang\n'
        'CEO, Kevand Co'
    ),
    'subject': 'Partnership Inquiry - Kevand Co',
    
    # Optional fields
    'address': '789 Executive Plaza',
    'city': 'New York',
    'state': 'NY',
    'zip': '10001',
    'country': 'United States'
}

# BOT CONFIGURATION
MAX_MANUAL_TABS_PER_BROWSER = 25
MAX_PARALLEL_SITES = 15
PAGES_TO_SCAN = 10
REQUEST_DELAY = (1, 3)
KEYWORDS_FILE = 'keywords.txt'
BLACKLIST_FILE = 'blacklist.txt'
SUBMIT_WAIT_TIME = 15  # Wait 15 seconds for submission to complete

# GLOBAL TRACKING
visited_domains = set()
blacklist_domains = set()
skipped_sites = set()
successful_submissions = set()
failed_sites = set()
total_browsers_created = 0
total_manual_tabs = 0
total_forms_filled = 0
session_start_time = datetime.now()

def load_blacklist():
    """Load blacklisted domains from blacklist.txt"""
    try:
        if not os.path.exists(BLACKLIST_FILE):
            with open(BLACKLIST_FILE, 'w') as f:
                f.write('')
            print(f"‚úÖ Created {BLACKLIST_FILE}")
            return set()
        
        with open(BLACKLIST_FILE, 'r') as f:
            domains = {line.strip() for line in f if line.strip()}
        
        print(f"‚úÖ Loaded {len(domains)} blacklisted domains")
        return domains
    except Exception as e:
        print(f"‚ùå Error loading blacklist: {e}")
        return set()

def add_to_blacklist(domain):
    """Add domain to blacklist and save to file"""
    try:
        blacklist_domains.add(domain)
        with open(BLACKLIST_FILE, 'a') as f:
            f.write(f"{domain}\n")
    except Exception as e:
        print(f"‚ùå Error writing to blacklist: {e}")

def load_keywords():
    """Load keywords from keywords.txt file"""
    try:
        if not os.path.exists(KEYWORDS_FILE):
            with open(KEYWORDS_FILE, 'w') as f:
                f.write('escrow lawyers\n')
            print(f"‚úÖ Created default {KEYWORDS_FILE}")
            return ['escrow lawyers']
        
        with open(KEYWORDS_FILE, 'r') as f:
            keywords = [line.strip() for line in f if line.strip()]
        
        if not keywords:
            print(f"‚ö†Ô∏è {KEYWORDS_FILE} is empty, using default")
            return ['escrow lawyers']
        
        print(f"‚úÖ Loaded {len(keywords)} keywords from {KEYWORDS_FILE}")
        return keywords
    except Exception as e:
        print(f"‚ùå Error loading keywords: {e}")
        return ['escrow lawyers']

def send_to_telegram(image_bytes, caption):
    """Send screenshot to Telegram"""
    try:
        files = {"photo": ("screenshot.png", image_bytes, 'image/png')}
        data = {"chat_id": CHAT_ID, "caption": caption[:1024]}
        response = requests.post(
            f"https://api.telegram.org/bot{BOT_TOKEN}/sendPhoto",
            files=files, data=data, timeout=10
        )
        return response.status_code == 200
    except Exception as e:
        print(f"Telegram error: {e}")
        return False

def send_text_to_telegram(message):
    """Send text message to Telegram"""
    try:
        data = {
            "chat_id": CHAT_ID,
            "text": message[:4096],
            "parse_mode": "HTML"
        }
        response = requests.post(
            f"https://api.telegram.org/bot{BOT_TOKEN}/sendMessage",
            json=data, timeout=10
        )
        return response.status_code == 200
    except Exception as e:
        print(f"Telegram error: {e}")
        return False

def get_session_stats():
    """Get current session statistics"""
    elapsed = datetime.now() - session_start_time
    
    stats = {
        'elapsed': str(elapsed).split('.')[0],
        'browsers': total_browsers_created,
        'success': len(successful_submissions),
        'manual': total_manual_tabs,
        'failed': len(failed_sites),
        'skipped': len(skipped_sites),
        'total': len(visited_domains),
        'forms_filled': total_forms_filled,
        'success_rate': f"{(len(successful_submissions) / max(len(visited_domains), 1) * 100):.1f}%"
    }
    return stats

def get_field_value(field_type):
    """Get appropriate value for field type"""
    field_mapping = {
        'first_name': CONTACT_INFO['first_name'],
        'fname': CONTACT_INFO['first_name'],
        'firstname': CONTACT_INFO['first_name'],
        'given_name': CONTACT_INFO['first_name'],
        'last_name': CONTACT_INFO['last_name'],
        'lname': CONTACT_INFO['last_name'],
        'lastname': CONTACT_INFO['last_name'],
        'surname': CONTACT_INFO['last_name'],
        'family_name': CONTACT_INFO['last_name'],
        'name': CONTACT_INFO['full_name'],
        'full_name': CONTACT_INFO['full_name'],
        'fullname': CONTACT_INFO['full_name'],
        'your_name': CONTACT_INFO['full_name'],
        'contact_name': CONTACT_INFO['full_name'],
        'email': CONTACT_INFO['email'],
        'mail': CONTACT_INFO['email'],
        'email_address': CONTACT_INFO['email'],
        'e_mail': CONTACT_INFO['email'],
        'phone': CONTACT_INFO['phone'],
        'telephone': CONTACT_INFO['phone'],
        'mobile': CONTACT_INFO['phone'],
        'cell': CONTACT_INFO['phone'],
        'tel': CONTACT_INFO['phone'],
        'phone_number': CONTACT_INFO['phone'],
        'contact_number': CONTACT_INFO['phone'],
        'company': CONTACT_INFO['company'],
        'business': CONTACT_INFO['company'],
        'organization': CONTACT_INFO['company'],
        'organisation': CONTACT_INFO['company'],
        'corporation': CONTACT_INFO['company'],
        'firm': CONTACT_INFO['company'],
        'company_name': CONTACT_INFO['company'],
        'business_name': CONTACT_INFO['company'],
        'job_title': CONTACT_INFO['job_title'],
        'title': CONTACT_INFO['job_title'],
        'position': CONTACT_INFO['job_title'],
        'role': CONTACT_INFO['job_title'],
        'occupation': CONTACT_INFO['job_title'],
        'website': CONTACT_INFO['website'],
        'url': CONTACT_INFO['website'],
        'web': CONTACT_INFO['website'],
        'site': CONTACT_INFO['website'],
        'message': CONTACT_INFO['message'],
        'comment': CONTACT_INFO['message'],
        'comments': CONTACT_INFO['message'],
        'details': CONTACT_INFO['message'],
        'description': CONTACT_INFO['message'],
        'inquiry': CONTACT_INFO['message'],
        'enquiry': CONTACT_INFO['message'],
        'question': CONTACT_INFO['message'],
        'questions': CONTACT_INFO['message'],
        'how_can_we_help': CONTACT_INFO['message'],
        'your_message': CONTACT_INFO['message'],
        'tell_us': CONTACT_INFO['message'],
        'subject': CONTACT_INFO['subject'],
        'topic': CONTACT_INFO['subject'],
        'regarding': CONTACT_INFO['subject'],
        'reason': CONTACT_INFO['subject'],
        'address': CONTACT_INFO['address'],
        'street': CONTACT_INFO['address'],
        'street_address': CONTACT_INFO['address'],
        'address_line_1': CONTACT_INFO['address'],
        'city': CONTACT_INFO['city'],
        'town': CONTACT_INFO['city'],
        'locality': CONTACT_INFO['city'],
        'state': CONTACT_INFO['state'],
        'province': CONTACT_INFO['state'],
        'region': CONTACT_INFO['state'],
        'zip': CONTACT_INFO['zip'],
        'zipcode': CONTACT_INFO['zip'],
        'postal': CONTACT_INFO['zip'],
        'postal_code': CONTACT_INFO['zip'],
        'postcode': CONTACT_INFO['zip'],
        'country': CONTACT_INFO['country'],
        'nation': CONTACT_INFO['country']
    }
    
    return field_mapping.get(field_type, '')

class ProFormDetector:
    """Professional form field detection with comprehensive pattern matching"""
    
    def __init__(self):
        self.field_patterns = {
            'first_name': [
                'first*name', 'fname', 'f*name', 'forename', 'given*name',
                'firstname', 'first_name', 'field*first', 'name*first', 'your*first',
                'givenname', 'given_name'
            ],
            'last_name': [
                'last*name', 'lname', 'l*name', 'surname', 'family*name',
                'lastname', 'last_name', 'field*last', 'name*last', 'your*last',
                'familyname', 'family_name'
            ],
            'name': [
                'full*name', '*name*', 'your*name', 'contact*name', 
                'client*name', 'person*name', 'fullname', 'full_name',
                'display*name', 'real*name'
            ],
            'email': [
                '*email*', '*e-mail*', '*mail*', 'e_mail', 'electronic*mail',
                'email*address', 'mail*address', 'contact*email', 'your*email',
                'user*email'
            ],
            'phone': [
                '*phone*', '*tel*', 'telephone', '*mobile*', '*cell*',
                'phone*number', 'contact*number', 'phonenumber', 'tel*number',
                'phone_number', 'telephone*number', 'mobile*number'
            ],
            'company': [
                '*company*', '*business*', '*organization*', '*organisation*',
                '*firm*', '*corporation*', 'employer', 'company*name', 'org*',
                'business*name', 'corporate*', 'firm*name', 'corp*'
            ],
            'job_title': [
                '*job*', '*title*', '*position*', '*role*', 'occupation',
                'job*title', 'work*title', 'your*title', 'your*position',
                'job_title', 'work*position'
            ],
            'address': [
                '*address*', '*street*', '*addr*', 'location',
                'street*address', 'address*line', 'address1', 'address_1',
                'address_line_1', 'line1'
            ],
            'city': [
                '*city*', '*town*', 'locality', 'municipality', 'urban'
            ],
            'state': [
                '*state*', '*province*', '*region*', 'county', 'territory'
            ],
            'zip': [
                '*zip*', '*postal*', 'postcode', 'zipcode', 'zip*code',
                'postal*code', 'post*code', 'post_code'
            ],
            'country': [
                '*country*', '*nation*', 'nationality', 'country*name'
            ],
            'website': [
                '*website*', '*url*', '*web*', 'site', 'homepage',
                'web*address', 'web*site', 'your*website', 'your*site'
            ],
            'subject': [
                '*subject*', '*topic*', '*regarding*', 'about', 'reason',
                're:', 'inquiry*type', 'service*needed', 'practice*area',
                'how*can*we*help', 'how*help', 'what*help', 'help',
                'question', 'issue', 'concern', 'matter', 'nature',
                'type*service', 'service*type', 'what*service',
                'contact*reason', 'reason*contact', 'contact*purpose',
                'inquiry', 'enquiry', 'request', 'need'
            ],
            'message': [
                '*message*', '*comment*', '*details*', '*description*', 
                '*inquiry*', '*enquiry*', '*question*', 'how*help',
                'additional*info', 'more*info', 'tell*us', 'your*message',
                'your*comment', 'your*inquiry', 'your*question'
            ]
        }
        
        self.submit_selectors = [
            "button[type='submit']", 
            "input[type='submit']",
            "button:has-text('Send')", 
            "button:has-text('Submit')", 
            "button:has-text('Contact')",
            "button:has-text('Submit Now')",
            "button:has-text('Send Message')",
            "button:has-text('Get in Touch')",
            "button:has-text('Send Now')",
            "button:has-text('Reach Out')",
            "button:has-text('Submit Form')",
            "button:has-text('Contact Us')",
            "button:has-text('Request')",
            "button:has-text('Inquire')",
            "button:has-text('Send Inquiry')",
            "button:has-text('Get Started')",
            "*[type='submit']", 
            ".submit-btn", 
            ".contact-btn", 
            ".send-btn",
            ".btn-submit",
            "input[value*='Submit']", 
            "input[value*='Send']",
            "button[class*='submit']", 
            "button[class*='send']",
            "button[class*='contact']",
            "form button:not([type='button']):not([type='reset'])"
        ]
        
        self.popup_selectors = [
            ".close", ".dismiss", ".btn-close", ".popup-close",
            ".modal-close", ".close-button", ".close-icon",
            "[aria-label='Close']", "[aria-label='Dismiss']",
            "[title='Close']", "[title='Dismiss']",
            "button:has-text('Close')", "button:has-text('Dismiss')",
            "button:has-text('No thanks')", "button:has-text('Maybe later')",
            "button:has-text('Not now')", "button:has-text('Decline')",
            "button:has-text('No Thank You')", "button:has-text('Skip')",
            ".cookie-accept", ".cookie-dismiss", ".cookie-close",
            "#cookie-notice button", ".gdpr-dismiss", ".accept-cookies",
            "button:has-text('Accept')", "button:has-text('Got it')",
            ".notification-close", ".alert-dismiss"
        ]

    async def close_popups(self, page):
        """Intelligently close popups and overlays"""
        try:
            await asyncio.sleep(0.5)
            
            for selector in self.popup_selectors:
                try:
                    buttons = await page.query_selector_all(selector)
                    for button in buttons[:3]:
                        if await button.is_visible():
                            try:
                                await button.click(timeout=2000)
                                await asyncio.sleep(0.3)
                            except:
                                pass
                except:
                    continue
        except:
            pass

    async def detect_all_fields(self, page):
        """Detect all fillable form fields with multiple strategies"""
        print("üîç SCANNING FORM FIELDS...")
        
        await self.close_popups(page)
        
        # Strategy 1: Look for all inputs and textareas
        all_elements = await page.query_selector_all('input, textarea, select')
        detected_fields = {}
        confidence_scores = {}
        
        for element in all_elements:
            if not await self.is_fillable(element):
                continue
                
            element_data = await self.get_element_data(element)
            field_type, confidence = await self.analyze_element(element_data)
            
            if field_type and confidence > 10:
                if field_type not in confidence_scores or confidence > confidence_scores[field_type]:
                    detected_fields[field_type] = element
                    confidence_scores[field_type] = confidence
                    detail = element_data['aria_label'] or element_data['placeholder'] or element_data['name'] or element_data['id'] or 'unknown'
                    print(f"  ‚úÖ {field_type}: {confidence}% ('{detail}')")
        
        print(f"üìä DETECTED {len(detected_fields)} FIELDS")
        return detected_fields

    async def is_fillable(self, element):
        """Check if element is fillable"""
        try:
            if not await element.is_visible():
                return False
                
            element_type = (await element.get_attribute('type') or '').lower()
            if element_type in ['hidden', 'submit', 'button', 'file', 'image', 'reset', 'checkbox', 'radio']:
                return False
                
            is_disabled = await element.get_attribute('disabled')
            is_readonly = await element.get_attribute('readonly')
            if is_disabled or is_readonly:
                return False
            
            try:
                box = await element.bounding_box()
                if not box or box['width'] == 0 or box['height'] == 0:
                    return False
            except:
                return False
                
            return True
        except:
            return False

    async def get_element_data(self, element):
        """Extract comprehensive element metadata"""
        tag_name = await element.evaluate('el => el.tagName.toLowerCase()')
        
        return {
            'id': (await element.get_attribute('id') or '').lower(),
            'name': (await element.get_attribute('name') or '').lower(),
            'type': (await element.get_attribute('type') or '').lower(),
            'placeholder': (await element.get_attribute('placeholder') or '').lower(),
            'class': (await element.get_attribute('class') or '').lower(),
            'aria_label': (await element.get_attribute('aria-label') or '').lower(),
            'title': (await element.get_attribute('title') or '').lower(),
            'data_name': (await element.get_attribute('data-name') or '').lower(),
            'autocomplete': (await element.get_attribute('autocomplete') or '').lower(),
            'tag': tag_name
        }

    async def analyze_element(self, element_data):
        """Analyze element with comprehensive pattern matching"""
        best_field = None
        best_confidence = 0
        
        for field_type, patterns in self.field_patterns.items():
            confidence = self.calculate_confidence(element_data, patterns, field_type)
            if confidence > best_confidence:
                best_field = field_type
                best_confidence = confidence
        
        return best_field, best_confidence

    def calculate_confidence(self, element_data, patterns, field_type):
        """Calculate confidence score using all available signals"""
        confidence = 0
        
        for pattern in patterns:
            pattern_clean = pattern.replace('*', '')
            
            if pattern_clean in element_data['id']:
                confidence = max(confidence, 95)
            
            if pattern_clean in element_data['name']:
                confidence = max(confidence, 92)
            
            if pattern_clean in element_data['autocomplete']:
                confidence = max(confidence, 88)
            
            if pattern_clean in element_data['data_name']:
                confidence = max(confidence, 85)
            
            if pattern_clean in element_data['aria_label']:
                confidence = max(confidence, 90)
            
            if pattern_clean in element_data['placeholder']:
                confidence = max(confidence, 75)
            
            if pattern_clean in element_data['title']:
                confidence = max(confidence, 70)
            
            if pattern_clean in element_data['class']:
                confidence = max(confidence, 60)
        
        if field_type == 'email' and element_data['type'] == 'email':
            confidence = max(confidence, 98)
        elif field_type == 'phone' and element_data['type'] == 'tel':
            confidence = max(confidence, 98)
        elif field_type == 'website' and element_data['type'] == 'url':
            confidence = max(confidence, 98)
        
        if field_type == 'message' and element_data['tag'] == 'textarea':
            confidence = max(confidence, 75)
        
        if field_type == 'subject' and 'subject' in element_data['aria_label']:
            confidence = 98
        
        autocomplete_hints = {
            'email': ['email'],
            'phone': ['tel', 'tel-national', 'tel-local'],
            'first_name': ['given-name'],
            'last_name': ['family-name'],
            'name': ['name'],
            'company': ['organization'],
            'address': ['street-address', 'address-line1'],
            'city': ['address-level2'],
            'state': ['address-level1'],
            'zip': ['postal-code'],
            'country': ['country', 'country-name']
        }
        
        if field_type in autocomplete_hints:
            for hint in autocomplete_hints[field_type]:
                if hint in element_data['autocomplete']:
                    confidence = max(confidence, 90)
        
        return confidence

    async def detect_checkboxes(self, page):
        """Detect and return all checkboxes that need to be checked"""
        try:
            checkboxes = await page.query_selector_all('input[type="checkbox"]')
            fillable_checkboxes = []
            
            for checkbox in checkboxes:
                if await checkbox.is_visible() and not await checkbox.is_checked():
                    # Get checkbox label to identify it
                    label_text = ""
                    try:
                        # Try to find associated label
                        checkbox_id = await checkbox.get_attribute('id')
                        if checkbox_id:
                            label = await page.query_selector(f'label[for="{checkbox_id}"]')
                            if label:
                                label_text = await label.text_content()
                    except:
                        pass
                    
                    fillable_checkboxes.append((checkbox, label_text.strip() if label_text else "Unknown"))
            
            return fillable_checkboxes
        except:
            return []

    async def detect_recaptcha(self, page):
        """Detect if reCAPTCHA is present on page"""
        try:
            page_content = await page.content()
            
            # Check for reCAPTCHA indicators
            recaptcha_indicators = [
                'g-recaptcha',
                'recaptcha',
                'hcaptcha',
                'captcha',
                'grecaptcha',
                'rc-anchor',
                'rc-image-tile-wrapper',
                'data-sitekey'
            ]
            
            for indicator in recaptcha_indicators:
                if indicator.lower() in page_content.lower():
                    return True
            
            return False
        except:
            return False

    async def handle_recaptcha_alert(self, page, contact_url):
        """Alert user about reCAPTCHA and keep tab open"""
        try:
            screenshot = await page.screenshot(full_page=False)
            
            alert_message = (
                f"üö® <b>RECAPTCHA DETECTED</b>\n"
                f"üåê {contact_url}\n"
                f"‚è∏Ô∏è Tab left open - SOLVE CAPTCHA\n"
                f"Bot will continue with other sites"
            )
            
            send_to_telegram(screenshot, alert_message)
            print(f"\nüö® RECAPTCHA FOUND ON: {contact_url}")
            print(f"   üì∏ Screenshot sent to Telegram")
            print(f"   ‚è∏Ô∏è Tab left open - you can solve it")
            print(f"   ‚úÖ Bot continuing with next sites\n")
            
        except Exception as e:
            print(f"Error sending reCAPTCHA alert: {e}")
        """Check all required checkboxes before submission"""
        checkboxes = await self.detect_checkboxes(page)
        
        if not checkboxes:
            print("   ‚úÖ No checkboxes to check")
            return True
        
        print(f"   üî≤ Found {len(checkboxes)} checkboxes - checking them...")
        
        try:
            for checkbox, label_text in checkboxes:
                try:
                    await checkbox.check()
                    print(f"      ‚úÖ Checked: {label_text[:50]}")
                    await asyncio.sleep(0.2)
                except Exception as e:
                    print(f"      ‚ö†Ô∏è Failed to check: {label_text[:50]} - {e}")
            
            return True
        except Exception as e:
            print(f"   ‚ùå Error checking checkboxes: {e}")
            return False

class SmartBotEngine:
    """Main bot engine with intelligent multi-site form filling"""
    
    def __init__(self):
        self.form_detector = ProFormDetector()
        self.playwright = None
        self.current_browser = None
        self.current_context = None
        self.search_page = None
        self.manual_attention_tabs = []
        self.keywords = []
        
    async def initialize(self):
        """Initialize browser and load keywords"""
        global total_browsers_created
        
        self.keywords = load_keywords()
        self.playwright = await async_playwright().start()
        await self.create_new_browser()
        
    async def create_new_browser(self):
        """Create new browser instance with optimized settings"""
        global total_browsers_created
        total_browsers_created += 1
        
        print(f"\n{'='*60}")
        print(f"ü™ü BROWSER #{total_browsers_created} INITIALIZING")
        print(f"{'='*60}")
        
        self.current_browser = await self.playwright.chromium.launch(
            headless=False,
            args=[
                '--start-maximized',
                '--disable-blink-features=AutomationControlled',
                '--disable-dev-shm-usage',
                '--no-sandbox'
            ]
        )
        
        self.current_context = await self.current_browser.new_context(
            viewport={'width': 1365, 'height': 901},
            user_agent='Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36'
        )
        
        self.search_page = await self.current_context.new_page()
        
        send_text_to_telegram(
            f"ü™ü <b>BROWSER #{total_browsers_created} READY</b>\n"
            f"üìù Capacity: {MAX_MANUAL_TABS_PER_BROWSER} manual tabs\n"
            f"üéØ Processing: {MAX_PARALLEL_SITES} sites in parallel"
        )
        
    async def should_create_new_browser(self):
        """Check if new browser instance needed"""
        return len(self.manual_attention_tabs) >= MAX_MANUAL_TABS_PER_BROWSER
    
    async def create_new_tab(self):
        """Create new tab in current browser context"""
        page = await self.current_context.new_page()
        return page
    
    def add_manual_tab(self, page, domain, reason):
        """Track tab requiring manual attention"""
        global total_manual_tabs
        total_manual_tabs += 1
        
        self.manual_attention_tabs.append({
            'page': page,
            'domain': domain,
            'reason': reason,
            'timestamp': datetime.now()
        })
        
        print(f"üö® MANUAL TAB: {domain} - {reason}")
        print(f"   üìä {len(self.manual_attention_tabs)}/{MAX_MANUAL_TABS_PER_BROWSER} tabs")

    async def extract_google_results(self, page):
        """Extract search results from Google with robust parsing"""
        await asyncio.sleep(2)
        
        results = []
        all_links = await page.query_selector_all('a')
        
        for link in all_links:
            try:
                href = await link.get_attribute('href')
                if not href:
                    continue
                
                if '/url?q=' in href:
                    actual_url = href.split('/url?q=')[1].split('&')[0]
                    actual_url = unquote(actual_url)
                    if self.is_valid_result(actual_url):
                        results.append(actual_url)
                elif href.startswith('http') and self.is_valid_result(href):
                    results.append(href)
                    
            except:
                continue
        
        unique = list(set(results))
        print(f"‚úÖ EXTRACTED {len(unique)} UNIQUE URLS")
        return unique
    
    def is_valid_result(self, url):
        """Validate if URL is a legitimate search result"""
        invalid_domains = [
            'google.com', 'webcache', 'translate', 'youtube.com',
            'facebook.com', 'linkedin.com', 'twitter.com', 'instagram.com'
        ]
        return (url.startswith('http') and 
                not any(domain in url for domain in invalid_domains) and
                not url.startswith('javascript:'))

    async def find_contact_page(self, page, website_url):
        """Find contact page - ONLY /contact, then search homepage for contact links"""
        domain = urlparse(website_url).netloc
        
        # Strategy 1: ONLY try /contact
        try:
            url = f"{website_url.rstrip('/')}/contact"
            await page.goto(url, timeout=15000, wait_until='domcontentloaded')
            await asyncio.sleep(1)
            if await self.has_contact_form(page):
                print(f"‚úÖ FOUND: {url}")
                return url
        except:
            pass
        
        # Strategy 2: Search homepage for ANY link with "contact" in href or text
        try:
            await page.goto(website_url, timeout=20000, wait_until='domcontentloaded')
            await asyncio.sleep(2)
            
            await self.form_detector.close_popups(page)
            
            # Find ALL links with "contact" in them
            all_links = await page.query_selector_all('a')
            contact_links = []
            
            for link in all_links:
                try:
                    href = await link.get_attribute('href')
                    text = (await link.text_content()).lower()
                    
                    # Check if "contact" in href or visible text
                    if href and ('contact' in href.lower() or 'contact' in text):
                        if not href.startswith(('javascript:', 'mailto:', 'tel:', '#')):
                            url = href if href.startswith('http') else f"{website_url.rstrip('/')}{href}"
                            contact_links.append(url)
                except:
                    continue
            
            # Try each contact link found
            for url in contact_links[:10]:  # Try up to 10 contact links
                try:
                    await page.goto(url, timeout=15000, wait_until='domcontentloaded')
                    await asyncio.sleep(1)
                    if await self.has_contact_form(page):
                        print(f"‚úÖ FOUND VIA LINK: {url}")
                        return url
                except:
                    continue
                    
        except:
            pass
        
        print("‚ùå NO CONTACT PAGE FOUND")
        return None

    async def has_contact_form(self, page):
        """Check if page contains a valid contact form with required fields"""
        try:
            form_selectors = [
                'form', '.contact-form', '#contactForm', '.wpcf7-form',
                '.elementor-form', '.wpforms-form', '.gform_wrapper',
                '.ninja-forms-form', '[class*="contact"]form', '#contact-form',
                '.form-container', '.contact-section form'
            ]
            
            for selector in form_selectors:
                forms = await page.query_selector_all(selector)
                if len(forms) > 0:
                    return True
            
            # Also check for any input/textarea elements (generic form detection)
            inputs = await page.query_selector_all('input, textarea')
            if len(inputs) >= 2:  # At least 2 input fields
                return True
            
            return False
        except:
            return False

    async def fill_and_submit_form(self, page, contact_url):
        """Fill and submit form with Kevin Fang's contact information"""
        global total_forms_filled
        
        print(f"üìù PROCESSING FORM: {contact_url}")
        
        try:
            await page.goto(contact_url, timeout=25000, wait_until='domcontentloaded')
            await asyncio.sleep(2)
            
            await self.form_detector.close_popups(page)
            
            # Take screenshot BEFORE filling
            screenshot_before = await page.screenshot(full_page=False)
            
            detected_fields = await self.form_detector.detect_all_fields(page)
            
            if not detected_fields:
                print("‚ùå NO FILLABLE FIELDS DETECTED")
                return 'no_fields', 0, 0, screenshot_before, None
            
            # Fill all detected fields
            fields_filled = 0
            total_fields = len(detected_fields)
            
            for field_type, element in detected_fields.items():
                try:
                    value = get_field_value(field_type)
                    if value:
                        await element.click()
                        await asyncio.sleep(0.1)
                        await element.fill('')
                        await asyncio.sleep(0.1)
                        await element.fill(str(value))
                        fields_filled += 1
                        print(f"  ‚úÖ {field_type}")
                        await asyncio.sleep(0.2)
                except Exception as e:
                    print(f"  ‚ö†Ô∏è {field_type} error: {e}")
            
            if fields_filled == 0:
                print("‚ùå NO FIELDS FILLED")
                return 'fill_failed', 0, total_fields, screenshot_before, None
            
            total_forms_filled += 1
            print(f"‚úÖ FILLED {fields_filled}/{total_fields} FIELDS")
            await asyncio.sleep(1)
            
            # Check and click checkboxes BEFORE submit
            print("üî≤ CHECKING AGREEMENTS/CHECKBOXES...")
            await self.form_detector.check_all_checkboxes(page)
            await asyncio.sleep(1)
            
            # Attempt form submission
            for selector in self.form_detector.submit_selectors:
                try:
                    btn = await page.query_selector(selector)
                    if btn and await btn.is_visible():
                        print(f"üöÄ SUBMITTING FORM...")
                        
                        await btn.scroll_into_view_if_needed()
                        await asyncio.sleep(0.5)
                        
                        original_url = page.url
                        await btn.click()
                        
                        # Wait for submission to complete (15 seconds)
                        print(f"‚è≥ WAITING {SUBMIT_WAIT_TIME} SECONDS FOR SUBMISSION...")
                        for i in range(SUBMIT_WAIT_TIME):
                            await asyncio.sleep(1)
                            
                            # Check for reCAPTCHA
                            if await self.form_detector.detect_recaptcha(page):
                                print(f"üö® RECAPTCHA DETECTED AFTER SUBMIT!")
                                await self.handle_recaptcha_alert(page, contact_url)
                                # Leave tab open and return as manual
                                screenshot_after = await page.screenshot(full_page=False)
                                return 'recaptcha', fields_filled, total_fields, screenshot_before, screenshot_after
                            
                            # Check for URL change (success indicator)
                            current_url = page.url
                            if current_url != original_url:
                                print(f"‚úÖ URL CHANGED: {original_url} ‚Üí {current_url}")
                                await asyncio.sleep(3)  # Wait for page to fully load
                                break
                            
                            # Check for success message
                            if i > 3:  # After 3 seconds, start checking for success
                                page_content = (await page.content()).lower()
                                success_indicators = [
                                    'thank you', 'success', 'submitted', 'message sent',
                                    'received', 'confirmation', 'successfully',
                                    'we received your', 'your inquiry has been', 'thank you for'
                                ]
                                if any(indicator in page_content for indicator in success_indicators):
                                    print(f"‚úÖ SUCCESS MESSAGE DETECTED")
                                    await asyncio.sleep(2)
                                    break
                        
                        # Take screenshot AFTER submit
                        screenshot_after = await page.screenshot(full_page=False)
                        
                        # Final check: Look for success page or error
                        page_content = (await page.content()).lower()
                        
                        # Check for reCAPTCHA one more time
                        if await self.form_detector.detect_recaptcha(page):
                            print(f"üö® RECAPTCHA BLOCKING FORM!")
                            await self.handle_recaptcha_alert(page, contact_url)
                            return 'recaptcha', fields_filled, total_fields, screenshot_before, screenshot_after
                        
                        success_indicators = [
                            'thank you', 'success', 'submitted', 'message sent',
                            'received', 'confirmation', 'successfully',
                            'we received your', 'your inquiry has been', 'thank you for'
                        ]
                        
                        if any(indicator in page_content for indicator in success_indicators):
                            print("üéâ SUCCESS PAGE DETECTED!")
                            return 'success', fields_filled, total_fields, screenshot_before, screenshot_after
                        
                        # Check for error indicators
                        error_indicators = [
                            'error', 'required field', 'invalid', 'please enter',
                            'must be', 'field is required', 'something went wrong'
                        ]
                        
                        if any(error in page_content for error in error_indicators):
                            print("‚ö†Ô∏è ERROR DETECTED - LEAVING FOR MANUAL")
                            return 'error_detected', fields_filled, total_fields, screenshot_before, screenshot_after
                        
                        # Unclear - needs manual check
                        print("‚ö†Ô∏è SUBMISSION UNCLEAR - NEEDS MANUAL VERIFICATION")
                        return 'unclear', fields_filled, total_fields, screenshot_before, screenshot_after
                        
                except Exception as e:
                    print(f"  ‚ö†Ô∏è Submit attempt failed: {e}")
                    continue
            
            # No submit button found
            print("‚ùå NO SUBMIT BUTTON FOUND")
            screenshot_after = await page.screenshot(full_page=False)
            return 'no_submit', fields_filled, total_fields, screenshot_before, screenshot_after
            
        except Exception as e:
            print(f"‚ùå FORM PROCESSING ERROR: {e}")
            return 'error', 0, 0, None, None

    async def send_alert(self, page, url, alert_type, filled, total, screenshot_before, screenshot_after):
        """Send screenshots and notification to Telegram"""
        try:
            if screenshot_before:
                caption_before = (
                    f"üìã <b>FORM FILLED</b>\n"
                    f"üåê {url}\n"
                    f"‚úÖ Filled: {filled}/{total} fields"
                )
                send_to_telegram(screenshot_before, caption_before)
                await asyncio.sleep(0.5)
            
            if screenshot_after:
                if alert_type == 'success':
                    caption_after = (
                        f"üéâ <b>SUBMISSION SUCCESS</b>\n"
                        f"üåê {url}\n"
                        f"‚úÖ Total successes: {len(successful_submissions)}"
                    )
                else:
                    caption_after = (
                        f"üö® <b>NEEDS MANUAL CHECK</b>\n"
                        f"üåê {url}\n"
                        f"‚ùì Status: {alert_type}\n"
                        f"üìù Filled: {filled}/{total} fields"
                    )
                send_to_telegram(screenshot_after, caption_after)
        except Exception as e:
            print(f"Alert error: {e}")

    async def process_website(self, website_url):
        """Process single website with complete workflow"""
        domain = urlparse(website_url).netloc
        
        # Check blacklist first
        if domain in blacklist_domains:
            return 'blacklisted'
        
        if domain in visited_domains:
            return 'skip'
        
        # Add to visited immediately
        visited_domains.add(domain)
        
        print(f"\n{'='*60}")
        print(f"üåê PROCESSING: {domain}")
        print(f"{'='*60}")
        
        # Check if need new browser
        if await self.should_create_new_browser():
            print(f"ü™ü {MAX_MANUAL_TABS_PER_BROWSER} MANUAL TABS REACHED")
            print(f"   Creating new browser instance...")
            await self.current_browser.close()
            await self.create_new_browser()
            self.manual_attention_tabs = []
        
        # Create new tab
        page = await self.create_new_tab()
        
        try:
            # Find contact page
            contact_url = await self.find_contact_page(page, website_url)
            if not contact_url:
                print("‚ùå NO CONTACT PAGE - SKIPPING")
                add_to_blacklist(domain)
                skipped_sites.add(domain)
                await page.close()
                return 'skip'
            
            # Fill and submit form
            result, filled, total, screenshot_before, screenshot_after = await self.fill_and_submit_form(page, contact_url)
            
            if result == 'success':
                successful_submissions.add(domain)
                add_to_blacklist(domain)
                await self.send_alert(page, contact_url, 'success', filled, total, screenshot_before, screenshot_after)
                await page.close()
                return 'success'
            elif result == 'recaptcha':
                # reCAPTCHA detected - leave tab open for manual solving
                failed_sites.add(domain)
                add_to_blacklist(domain)
                self.add_manual_tab(page, domain, 'recaptcha')
                await self.send_alert(page, contact_url, 'recaptcha', filled, total, screenshot_before, screenshot_after)
                # DO NOT close page - user needs to solve it
                return 'manual'
            else:
                # Other errors - leave tab open for manual
                failed_sites.add(domain)
                add_to_blacklist(domain)
                self.add_manual_tab(page, domain, result)
                await self.send_alert(page, contact_url, result, filled, total, screenshot_before, screenshot_after)
                # DO NOT close page - leave it open for manual
                return 'manual'
                
        except Exception as e:
            print(f"‚ùå PROCESSING ERROR: {e}")
            add_to_blacklist(domain)
            await page.close()
            return 'error'

    async def process_batch(self, websites):
        """Process multiple websites in parallel"""
        print(f"\nüîÑ PROCESSING BATCH: {len(websites)} sites")
        
        tasks = []
        for website in websites:
            task = asyncio.create_task(self.process_website(website))
            tasks.append(task)
            await asyncio.sleep(random.uniform(*REQUEST_DELAY))
        
        results = await asyncio.gather(*tasks, return_exceptions=True)
        
        success_count = len([r for r in results if r == 'success'])
        manual_count = len([r for r in results if r == 'manual'])
        
        print(f"‚úÖ Batch complete: {success_count} success, {manual_count} manual")
        return results

    async def send_status(self):
        """Send comprehensive status update"""
        stats = get_session_stats()
        
        status = (
            f"üìä <b>STATUS UPDATE</b>\n"
            f"‚è±Ô∏è Runtime: {stats['elapsed']}\n"
            f"ü™ü Browsers: {stats['browsers']}\n"
            f"üìù Manual tabs: {len(self.manual_attention_tabs)}/{MAX_MANUAL_TABS_PER_BROWSER}\n"
            f"‚úÖ Success: {stats['success']}\n"
            f"üö® Manual total: {stats['manual']}\n"
            f"‚ùå Failed: {stats['failed']}\n"
            f"‚è© Skipped: {stats['skipped']}\n"
            f"üåê Total processed: {stats['total']}\n"
            f"üìã Forms filled: {stats['forms_filled']}\n"
            f"üìà Success rate: {stats['success_rate']}"
        )
        
        send_text_to_telegram(status)
        print(f"\n{status}\n")

    async def scan_google(self, keyword):
        """Scan Google search for keyword"""
        print(f"\n{'='*60}")
        print(f"üîç SCANNING KEYWORD: {keyword}")
        print(f"{'='*60}")
        
        search_url = f"https://www.google.com/search?q={keyword.replace(' ', '+')}"
        await self.search_page.goto(search_url, timeout=20000, wait_until='domcontentloaded')
        await asyncio.sleep(3)
        
        # Handle Google CAPTCHA if present
        if "google.com/sorry" in self.search_page.url:
            print("üö® GOOGLE CAPTCHA - Manual intervention needed")
            input(">>> PRESS ENTER AFTER SOLVING CAPTCHA <<<")
            await self.search_page.reload()
            await asyncio.sleep(3)
        
        # Process each page
        for page_num in range(1, PAGES_TO_SCAN + 1):
            print(f"\nüìÑ GOOGLE PAGE {page_num}/{PAGES_TO_SCAN}")
            
            results = await self.extract_google_results(self.search_page)
            
            if not results:
                print("‚ö†Ô∏è NO RESULTS - Moving to next page")
                if page_num < PAGES_TO_SCAN:
                    await self.search_page.goto(f"{search_url}&start={page_num * 10}", timeout=15000, wait_until='domcontentloaded')
                    await asyncio.sleep(2)
                continue
            
            print(f"‚úÖ FOUND {len(results)} SITES")
            
            # Process results in batches
            for i in range(0, len(results), MAX_PARALLEL_SITES):
                batch = results[i:i + MAX_PARALLEL_SITES]
                await self.process_batch(batch)
                await self.send_status()
                await asyncio.sleep(2)
            
            # Navigate to next page
            if page_num < PAGES_TO_SCAN:
                await self.search_page.goto(f"{search_url}&start={page_num * 10}", timeout=15000, wait_until='domcontentloaded')
                await asyncio.sleep(2)

    async def run(self):
        """Main bot loop"""
        print("\n" + "="*60)
        print("üöÄ ULTRA FORM BOT v6.0 - PRODUCTION")
        print("="*60)
        print("‚ú® IMPROVEMENTS:")
        print("  ‚úÖ Dual screenshots (before & after submit)")
        print("  ‚úÖ Auto-check all checkboxes before submit")
        print("  ‚úÖ Wait 15 seconds for form submission")
        print("  ‚úÖ Better form field detection")
        print("  ‚úÖ Never close tab until 100% sure submitted")
        print("  ‚úÖ Improved error detection")
        print("="*60 + "\n")
        
        await self.initialize()
        
        cycle = 0
        while True:
            cycle += 1
            print(f"\n{'='*60}")
            print(f"üîÑ CYCLE {cycle}")
            print(f"{'='*60}")
            
            try:
                for keyword in self.keywords:
                    await self.scan_google(keyword)
                
                stats = get_session_stats()
                final_status = (
                    f"üéä <b>CYCLE {cycle} COMPLETE</b>\n"
                    f"‚è±Ô∏è Runtime: {stats['elapsed']}\n"
                    f"‚úÖ Success: {stats['success']}\n"
                    f"üö® Manual: {stats['manual']}\n"
                    f"üìà Rate: {stats['success_rate']}"
                )
                
                send_text_to_telegram(final_status)
                print(f"\n{final_status}\n")
                
                print("‚ôæÔ∏è NEXT CYCLE IN 30 SECONDS...")
                await asyncio.sleep(30)
                
            except Exception as e:
                print(f"üí• CYCLE ERROR: {e}")
                print("üîÑ RESTARTING IN 10 SECONDS...")
                await asyncio.sleep(10)

async def main():
    global blacklist_domains
    blacklist_domains = load_blacklist()
    
    bot = SmartBotEngine()
    
    try:
        await bot.run()
    except KeyboardInterrupt:
        print("\n\n" + "="*60)
        print("‚è∏Ô∏è  SCRIPT STOPPED BY USER (Ctrl+C)")
        print("="*60)
        print("‚úÖ BROWSER REMAINS OPEN FOR MANUAL COMPLETION")
        print("üìù Complete manual tabs, then restart script")
        print("="*60 + "\n")
        return

if __name__ == "__main__":
    print("\n" + "="*60)
    print("üöÄ ULTRA FORM FILLER BOT v6.0")
    print("="*60)
    print("‚ú® NEW IN v6.0:")
    print("  ‚úÖ Dual screenshots (before & after)")
    print("  ‚úÖ Auto-click all checkboxes")
    print("  ‚úÖ 15 second submit wait")
    print("  ‚úÖ Never close tab prematurely")
    print("  ‚úÖ Better error handling")
    print("="*60 + "\n")
    
    if not os.path.exists(BLACKLIST_FILE):
        with open(BLACKLIST_FILE, 'w') as f:
            f.write('')
    
    try:
        asyncio.run(main())
    except KeyboardInterrupt:
        print("\n‚è∏Ô∏è  BOT STOPPED - BROWSER STILL RUNNING")
